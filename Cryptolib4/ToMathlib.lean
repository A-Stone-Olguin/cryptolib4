import Mathlib.Data.Bitvec.Defs
import Mathlib.Data.ZMod.Basic
import Mathlib.GroupTheory.SpecificGroups.Cyclic
import Mathlib.GroupTheory.Subgroup.Basic
import Mathlib.Probability.ProbabilityMassFunction.Basic
import Mathlib.Probability.ProbabilityMassFunction.Monad
import Mathlib.Probability.ProbabilityMassFunction.Constructions

-- To Probability : Might not be needed

noncomputable section 

instance : Monad Pmf where
  pure := Pmf.pure 
  bind := Pmf.bind

instance : LawfulFunctor Pmf where
  id_map := Pmf.map_id
  comp_map := λ f g x => (Pmf.map_comp f x g).symm
  map_const := sorry

instance : LawfulMonad Pmf where
  pure_bind := Pmf.pure_bind
  bind_assoc := Pmf.bind_bind
  bind_pure_comp := Pmf.bind_pure_comp 
  bind_map := sorry

#check Pmf.map_const
#check Pmf.map
#check Functor.mapConst


lemma range_pos_ne_zero (n : ℕ) (n_pos : 0 < n) : Multiset.range n ≠ 0 := by 
  apply (Multiset.card_pos).mp 
  rw [Multiset.card_range]
  exact n_pos


-- Every element in the cyclic group is generated by the powers of g
def IsCyclic.generator {G : Type} [Group G] [IsCyclic G] (g : G): Prop := 
  ∀ (x : G), x ∈ Subgroup.zpowers g


namespace Bitvec


instance : ∀ (n : ℕ), Fintype (Bitvec n) := by 
  intro n; exact Vector.fintype

lemma card (n : ℕ) : Fintype.card (Bitvec n) = 2^n := card_vector n

lemma multiset_ne_zero (n : ℕ) : (instForAllNatFintypeBitvec n).elems.val ≠ 0 := by 
  apply (Multiset.card_pos).mp 
  have h : Multiset.card ((instForAllNatFintypeBitvec n).elems.val) = 2^n := Bitvec.card n
  rw [h]
  simp


end Bitvec


namespace ZMod

-- TODO Add ZMod Group Instance

end ZMod


-- In Lupo's code, the mem_zpowers_iff lemma is already implemented in Mathlib

-- This is division algorithm... is it already implemented?
lemma exists_mod_add_div (a b : ℕ) : ∃ (m : ℕ), a = a % b + b * m := by 
  use (a/b)
  exact (Nat.mod_add_div a b).symm

