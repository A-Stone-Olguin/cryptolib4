import Mathlib.Data.Bitvec.Defs
import Mathlib.Data.ZMod.Basic
import Mathlib.GroupTheory.SpecificGroups.Cyclic
import Mathlib.GroupTheory.Subgroup.Basic
import Mathlib.Probability.ProbabilityMassFunction.Basic
import Mathlib.Probability.ProbabilityMassFunction.Monad
import Mathlib.Probability.ProbabilityMassFunction.Constructions

noncomputable section 

instance : Monad Pmf where
  pure := Pmf.pure 
  bind := Pmf.bind

instance : LawfulFunctor Pmf where
  id_map := Pmf.map_id
  comp_map := λ f g x => (Pmf.map_comp f x g).symm
  map_const := rfl

instance : LawfulMonad Pmf where
  pure_bind := Pmf.pure_bind
  bind_assoc := Pmf.bind_bind
  bind_pure_comp := Pmf.bind_pure_comp 
  bind_map := λ _ _ => rfl

lemma range_pos_ne_zero (n : ℕ) (n_pos : 0 < n) : Multiset.range n ≠ 0 := by 
  apply (Multiset.card_pos).mp 
  rw [Multiset.card_range]
  exact n_pos


-- Every element in the cyclic group is generated by the powers of g
def IsCyclic.generator {G : Type} [Group G] [IsCyclic G] (g : G): Prop := 
  ∀ (x : G), x ∈ Subgroup.zpowers g


namespace Bitvec

instance : ∀ (n : ℕ), Fintype (Bitvec n) := by 
  intro n; exact Vector.fintype

lemma card (n : ℕ) : Fintype.card (Bitvec n) = 2^n := card_vector n

lemma multiset_ne_zero (n : ℕ) : (@Fintype.elems (Bitvec n)).val ≠ 0 := by 
  apply (Multiset.card_pos).mp 
  have h : Multiset.card ((@Fintype.elems (Bitvec n)).val) = 2^n := Bitvec.card n
  rw [h]
  simp

end Bitvec


namespace ZMod

-- 0 < n fact not needed... will keep in case of future uses
instance : ∀ (n : ℕ) [NeZero n], Group (ZMod n) := fun
  | .zero => Multiplicative.group
  | .succ _ => Multiplicative.group

-- instance : ∀ (n : ℕ) [Fact (0 < n)], Group (ZMod n) := fun
--   | .zero => Multiplicative.group
--   | .succ _ => Multiplicative.group

end ZMod


-- In Lupo's code, the mem_zpowers_iff lemma is already implemented in Mathlib

-- This is division algorithm... is it already implemented?
lemma exists_mod_add_div (a b : ℕ) : ∃ (m : ℕ), a = a % b + b * m := by 
  use (a/b)
  exact (Nat.mod_add_div a b).symm


variable (G : Type) [i1 : Fintype G] [i2 : Group G]
namespace Group

lemma multiset_ne_zero : (@Fintype.elems G).val ≠ 0 := by 
  have e : G := (i2.one)
  have h1 : e ∈ (@Fintype.elems G).val := Finset.mem_univ e 
  have h2 : 0 < Multiset.card (@Fintype.elems G).val := by
    apply (Multiset.card_pos_iff_exists_mem).mpr
    exact Exists.intro e h1
  exact Multiset.card_pos.mp h2

end Group

lemma inv_pow_eq_card_sub_pow (g : G) (m : ℕ) (H : m ≤ Fintype.card G) : 
  (g ^ m)⁻¹ = g^(Fintype.card G - m) := by 
    have h : (g ^ m) * g ^ (Fintype.card G - m) = 1 := by 
      rw [← pow_add]
      rw [Nat.add_sub_of_le]
      exact pow_card_eq_one
      exact H
    exact inv_eq_of_mul_eq_one_right h

-- The pow_eq_mod_card lemma is already implemented in mathlib